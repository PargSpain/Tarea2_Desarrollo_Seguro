import subprocess
import socket
import requests
import os
import logging  # Importa el módulo logging

# Configura el logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def ejecutar_comando(comando):
    """
    Ejecuta un comando en la terminal y devuelve la salida.

    Args:
        comando (str): El comando a ejecutar.

    Returns:
        str: La salida del comando, o None si hay un error.
    """
    try:
        resultado = subprocess.run(comando, capture_output=True, text=True, check=True)
        return resultado.stdout.strip()
    except subprocess.CalledProcessError as e:
        logging.error(f"Error al ejecutar el comando '{comando}': {e}")  # Usa logging.error
        return None

def verificar_conexion(url):
    """
    Verifica si se puede establecer una conexión con la URL proporcionada.

    Args:
        url (str): La URL a verificar.

    Returns:
        bool: True si la conexión se establece, False en caso contrario.
    """
    try:
        response = requests.get(url)
        response.raise_for_status()  # Lanza una excepción para códigos de error HTTP
        logging.info(f"Conexión exitosa con {url}")  # Usa logging.info
        return True
    except requests.exceptions.RequestException as e:
        logging.error(f"No se pudo conectar a {url}: {e}")  # Usa logging.error
        return False

def escanear_puertos(host, puertos):
    """
    Escanea los puertos especificados en el host para determinar si están abiertos.

    Args:
        host (str): El host a escanear (dirección IP o nombre de dominio).
        puertos (list): Una lista de los puertos a escanear.

    Returns:
        dict: Un diccionario donde las claves son los puertos y los valores son True (abierto) o False (cerrado).
    """
    puertos_abiertos = {}
    for puerto in puertos:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)  # Establece un timeout de 1 segundo
            resultado = sock.connect_ex((host, puerto))
            if resultado == 0:
                logging.info(f"Puerto {puerto} abierto en {host}")  # Usa logging.info
                puertos_abiertos[puerto] = True
            else:
                logging.info(f"Puerto {puerto} cerrado en {host}")  # Usa logging.info
                puertos_abiertos[puerto] = False
            sock.close()
        except socket.error as e:
            logging.error(f"Error al escanear el puerto {puerto} en {host}: {e}")  # Usa logging.error
            puertos_abiertos[puerto] = False
    return puertos_abiertos

def realizar_fuzzing(url, payloads):
    """
    Realiza fuzzing básico en una URL para identificar posibles vulnerabilidades.

    Args:
        url (str): La URL a atacar.
        payloads (list): Una lista de payloads para usar en el fuzzing.
    """
    logging.info(f"Realizando fuzzing en {url}...")  # Usa logging.info
    for payload in payloads:
        try:
            data = {'parametro': payload}  # Simula un envío de datos POST
            response = requests.post(url, data=data)
            # Aquí se podrían añadir comprobaciones más sofisticadas, como buscar patrones
            # específicos en la respuesta, analizar los códigos de estado HTTP, etc.
            if response.status_code != 200:
                logging.warning(f"  Anomalía detectada con payload '{payload}': Código de estado {response.status_code}")  # Usa logging.warning
            else:
                logging.info(f"  No se detectó anomalía con payload '{payload}'")  # Usa logging.info
        except requests.exceptions.RequestException as e:
            logging.error(f"  Error al enviar payload '{payload}': {e}")  # Usa logging.error

def verificar_headers_seguridad(url):
    """
    Verifica si los encabezados de seguridad HTTP están configurados correctamente.

    Args:
        url (str): La URL a verificar.
    """
    try:
        response = requests.get(url)
        headers = response.headers
        logging.info(f"Verificando encabezados de seguridad para {url}...")  # Usa logging.info
        
        encabezados_verificar = {
            'X-Frame-Options': 'SAMEORIGIN',
            'X-Content-Type-Options': 'nosniff',
            'Strict-Transport-Security': 'max-age',  # Comprobar solo la presencia
            'Content-Security-Policy': 'default-src' # Comprobar solo la presencia
        }
        
        for encabezado, valor_esperado in encabezados_verificar.items():
            if encabezado in headers:
                if valor_esperado in headers[encabezado]:
                    logging.info(f"  {encabezado} está configurado correctamente: {headers[encabezado]}")  # Usa logging.info
                else:
                    logging.warning(f"  {encabezado} no tiene el valor esperado: {headers[encabezado]}")  # Usa logging.warning
            else:
                logging.warning(f"  {encabezado} no está configurado")  # Usa logging.warning
                
    except requests.exceptions.RequestException as e:
        logging.error(f"  Error al obtener los encabezados de {url}: {e}")  # Usa logging.error

def verificar_version_framework(url):
    """
    Intenta identificar la versión del framework utilizado por la aplicación.
    Esto es una prueba de penetración informativa, no un ataque directo.
    Args:
        url (str): La URL de la aplicación web.
    """
    logging.info(f"Intentando identificar la versión del framework en {url}...")  # Usa logging.info
    try:
        response = requests.get(url)
        # Búsqueda de patrones comunes en las cabeceras y el contenido de la respuesta
        if "X-Powered-By" in response.headers:
            logging.info(f"  Posible versión de framework encontrada en la cabecera X-Powered-By: {response.headers['X-Powered-By']}")  # Usa logging.info
        if "PHP" in response.text:
            logging.info("  Posible indicio de PHP encontrado en el contenido de la página")  # Usa logging.info
        # Se podrían agregar más comprobaciones para otros frameworks (ej., para buscar "ASP.NET" en el contenido)

    except requests.exceptions.RequestException as e:
        logging.error(f"  Error al obtener la respuesta de {url}: {e}")  # Usa logging.error
    logging.info("  La identificación de la versión del framework es una prueba informativa y puede no ser precisa.")  # Usa logging.info



def main():
    """
    Función principal que ejecuta las pruebas de penetración básicas.
    """
    logging.info("Ejecutando pruebas de penetración básicas...")  # Usa logging.info

    url_objetivo = "http://localhost:8000"  # Reemplazar con la URL de tu aplicación
    
    if verificar_conexion(url_objetivo):
        puertos_a_escanear = [80, 443, 8000, 8080]  # Puertos comunes
        escanear_puertos(url_objetivo, puertos_a_escanear)
        
        payloads_xss = [
            "<script>alert('XSS')</script>",
            "<h1>XSS</h1>",
            "<img src=x onerror=alert('XSS')>",
            "'\"<script>alert(0)</script>'"
        ]
        realizar_fuzzing(url_objetivo, payloads_xss)
        verificar_headers_seguridad(url_objetivo)
        verificar_version_framework(url_objetivo)

    logging.info("Pruebas de penetración básicas completadas.")  # Usa logging.info


if __name__ == "__main__":
    main()